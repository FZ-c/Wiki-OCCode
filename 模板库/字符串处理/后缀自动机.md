---
title: 后缀自动机
description: 
published: true
date: 2021-11-22T08:04:12.763Z
tags: 模板-字符串处理, 后缀自动机
editor: markdown
dateCreated: 2021-11-19T03:17:10.575Z
---

# 基本函数

```cpp
#include <cstring>

const int CHAR = 26;
const int MAXN = 250010;
struct SAM_Node
{
	SAM_Node* fa, * next[CHAR];
	int len;
	long long cnt;
	void clear()
	{
		fa = 0;
		memset(next, 0, sizeof(next));
		cnt = 0;
	}
}pool[MAXN * 2];
SAM_Node* root, * tail;
SAM_Node* newNode(int len)
{
	SAM_Node* cur = tail++;
	cur->clear();
	cur->len = len;
	return cur;
}
void SAM_init()
{
	tail = pool;
	root = newNode(0);
}
SAM_Node* extend(SAM_Node* last,int x)
{
	SAM_Node* p = last, * np = newNode(p->len + 1);
	while (p && !p->next[x]) p->next[x] = np, p = p->fa;
	if (!p) 
		np->fa = root;
	else
	{
		SAM_Node* q = p->next[x];
		if (q->len == p->len + 1) 
			np->fa = q;
		else
		{
			SAM_Node* nq = newNode(p->len + 1);
			memcpy(nq->next, q->next, sizeof(q->next));
			nq->fa = q->fa;
			q->fa = np->fa = nq;
			while (p && p->next[x] == q) p->next[x] = nq, p = p->fa;
		}
	}
	return np;
}
```

# 例题1

> [CC TSUBSTR](http://www.codechef.com/problems/TSUBSTR/)
> 给了一个 Trie 树，求 Trie 子树上的第 k 大的子串。

```cpp
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

const int CHAR = 26;
const int MAXN = 250010;
struct SAM_Node
{
	SAM_Node* fa, * next[CHAR];
	int len;
	long long cnt;
	void clear()
	{
		fa = 0;
		memset(next, 0, sizeof(next));
		cnt = 0;
	}
}pool[MAXN * 2];
SAM_Node* root, * tail;
SAM_Node* newNode(int len)
{
	SAM_Node* cur = tail++;
	cur->clear();
	cur->len = len;
	return cur;
}
void SAM_init()
{
	tail = pool;
	root = newNode(0);
}
SAM_Node* extend(SAM_Node* last,int x)
{
	SAM_Node* p = last, * np = newNode(p->len + 1);
	while (p && !p->next[x]) p->next[x] = np, p = p->fa;
	if (!p) 
		np->fa = root;
	else
	{
		SAM_Node* q = p->next[x];
		if (q->len == p->len + 1) 
			np->fa = q;
		else
		{
			SAM_Node* nq = newNode(p->len + 1);
			memcpy(nq->next, q->next, sizeof(q->next));
			nq->fa = q->fa;
			q->fa = np->fa = nq;
			while (p && p->next[x] == q) p->next[x] = nq, p = p->fa;
		}
	}
	return np;
}
char str[MAXN];
struct Edge
{
	int to, next;
}edge[MAXN * 2];
int head[MAXN], tot;
void addedge(int u, int v)
{
	edge[tot].to = v;
	edge[tot].next = head[u];
	head[u] = tot++;
}

SAM_Node* end[MAXN];
int topcnt[MAXN];//拓扑排序使用
SAM_Node* topsam[MAXN * 2];
char s2[40];
int order[40];

int main()
{
	int n, Q;
	while (scanf("%d%d", &n, &Q) == 2)
	{
		scanf("%s", str + 1);
		memset(head, -1, sizeof(head));
		tot = 0;
		int u, v;
		for (int i = 1; i < n; i++)
		{
			scanf("%d%d", &u, &v);
			addedge(u, v); addedge(v, u);
		}
		addedge(0, 1);
		SAM_init();
		memset(end, 0, sizeof(end));
		end[0] = root;
		queue<int> q;
		q.push(0);
		while (!q.empty())
		{
			u = q.front();
			q.pop();
			for (int i = head[u]; i != -1; i = edge[i].next)
			{
				v = edge[i].to;
				if (end[v] != 0) continue;
				end[v] = extend(end[u], str[v] - 'a');
				q.push(v);
			}
		}
		memset(topcnt, 0, sizeof(topcnt));
		int num = tail - pool;
		for (int i = 0; i < num; i++) topcnt[pool[i].len]++;
		for (int i = 1; i <= n; i++) topcnt[i] += topcnt[i - 1];
		for (int i = 0; i < num; i++) topsam[--topcnt[pool[i].len]] = &pool[i];

		for (int i = num - 1; i >= 0; i--)
		{
			SAM_Node* p = topsam[i];
			p->cnt = 1;
			for (int i = 0; i < 26; i++)
			{
				if (p->next[i]) p->cnt += p->next[i]->cnt;
			}
		}
		printf("%lld\n", root->cnt);
		long long k;
		while (Q--)
		{
			scanf("%s", s2);
			for (int i = 0; i < 26; i++) order[i] = s2[i] - 'a';
			scanf("%lld", &k);
			if (k > root->cnt)
			{
				printf("-1\n");
				continue;
			}
			SAM_Node* p = root;
			while ((--k) > 0)
			{
				for (int i = 0; i < 26; i++)
				{
					if (p->next[order[i]])
					{
						if (k <= p->next[order[i]]->cnt)
						{
							printf("%c", 'a' + order[i]);
							p = p->next[order[i]];
							break; //这个不要忘记
						}
						else
							k -= p->next[order[i]]->cnt;
					}
				}
			}
			printf("\n");
		}
	}
	return 0;
}
```

# 例题2

> [CF 129E](http://codeforces.com/contest/204/problem/E)
> 给了 n 个字符串，求每个字符串有多少个至少出现在 k 个字符串中的子串 fail 树，两遍 dfs, 经典题。

```cpp

```