---
title: 递归
description: 
published: true
date: 2021-11-11T09:42:59.529Z
tags: 算法-基础
editor: markdown
dateCreated: 2021-11-11T08:28:49.685Z
---

# 递归

## 定义

简单的说，就是函数自己调用自己。（可以是直接的，也可以是间接的）

递归的实质是将大问题转化为小问题去求解。而对于原子问题（最小的问题），给出答案作为递归的终点。

如果还是一脸懵逼的话，看一下下面的例题。

## 优势

结构清晰，可读性强！

## 例题1：求N!

> 给定一个正整数$N$，求$N!$。
  
## 分析

  我们知道，$N! = (N-1)!*N$。所以我们可以得到下面的函数：
$$
  f(n) =\begin{cases}
f(n-1) * n & n > 1\\
1 & n = 1\\
\end{cases}
$$

当$n > 1$时，调用函数$f$求解$n-1!$再乘$n$，当$n$为1时，返回1，1为递归终点且所有$n > 1$的递归最终都会到达$f(1)$后回溯。

## 代码

```cpp
#include <iostream>

using namespace std;

int f(int n)
{
	if (n == 1) return 1;
	return f(n - 1) * n;
}

int main()
{
	int n;
	cin >> n;
	cout << f(n);
	return 0;
}
```

## 例题2：斐波那契数列

> 已知$f(1) = f(2) = 1,f(n) = f(n-1) + f(n-2)(n > 2)$。给定$N$求$f(N)$的值。

建议先自己写一下运行一下，然后再看解析。 :smile:

<details>
  <summary>解析</summary>
  
### 分析
  
  题目已经直接给出了递归式子，我们可以很容易地写出递归代码。
  
### 递归代码

```cpp
#include <iostream>

using namespace std;

int f(int n)
{
	if (n == 1 || n == 2) return 1;
	return f(n - 1) + f(n - 2);
}

int main()
{
	int n;
	cin >> n;
	cout << f(n);
	return 0;
}
```
  
### 注意

递归深度和调用次数

> 在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成**栈溢出**的后果。
> 而调用次数过大，会造成超时的情况；如果递归没有写好递归终点，则会出现死循环的情况。~~（其实也不是死循环，最后会因为递归层数过大溢出崩掉）~~
{.is-warning}

我们尝试研究一下上面的递归代码会进行怎样的调用。
  
我们知道，$f(1)$和$f(2)$不会进行递归直接返回答案，总调用次数是$1$。
  
那么$f(3)$会调用$f(2)$和$f(1)$，总调用次数是$1+1=2$。

$f(4)$会调用$f(2)$和$f(3)$，总调用次数是$1+2=3$。
  
发现规律了吗？求解$f(n)$的总调用次数就是$f(n)$次！
  
这个调用次数是非常恐怖的大，所以单就调用次数而言就已经超时了。
  
### 优化：递推
  
我们可以使用数组来存下值，从$f(3)$开始逐步推到$f(N)$。
使用数组的目的是**防止重复的递归求解**。

### 递推代码
  
```cpp
#include <iostream>

using namespace std;

#define MAXN 10000

int ans[10000];

int main()
{
	int n;
	cin >> n;
	ans[1] = ans[2] = 1;
	for (int i = 3; i <= n; i++)
	{
		ans[i] = ans[i - 1] + ans[i - 2];
	}
	cout << ans[n];
	return 0;
}
```
  
</details>



